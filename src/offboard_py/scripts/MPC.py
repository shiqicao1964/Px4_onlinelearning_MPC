
import os
import sys
import shutil
import casadi as cs
import numpy as np
from copy import copy
import matplotlib
import matplotlib.pyplot as plt
from acados_template import AcadosOcp, AcadosOcpSolver, AcadosModel
from math import sqrt
import math 
from casadi.casadi import *
import time


class px4_quad:
    def __init__(self):
        # Quadrotor intrinsic parameters
        self.J = np.array([.03, .03, .06])  # N m s^2 = kg m^2
        self.mass = 1.5  # kg

        # Length of motor to CoG segment
        self.length = 0.47 / 2  # m
        self.max_thrust = 20
        self.g = np.array([[0], [0], [9.81]])  # m s^-2
        h = np.cos(np.pi / 4) * self.length
        self.x_f = np.array([h, -h, -h, h])
        self.y_f = np.array([-h, -h, h, h])
        self.c = 0.013  # m   (z torque generated by each motor)
        self.z_l_tau = np.array([-self.c, self.c, -self.c, self.c])

        # Input constraints
        self.max_input_value = 2  # Motors at full thrust
        self.min_input_value = 0  # Motors turned off
        self.min_u = self.min_input_value
        self.max_u = self.max_input_value



def linear_quad_model():

    # Declare model variables
    roll = cs.MX.sym('roll')  # position
    pitch = cs.MX.sym('pitch')
    yaw = cs.MX.sym('yaw')

    x_ = cs.MX.sym('x_')
    y_ = cs.MX.sym('y_')
    z_ = cs.MX.sym('z_')

    p = cs.MX.sym('p')
    q = cs.MX.sym('q')
    r = cs.MX.sym('r')

    vx = cs.MX.sym('vx')
    vy = cs.MX.sym('vy')
    vz = cs.MX.sym('vz')
    # Full state vector (12-dimensional)
    x = cs.vertcat(x_,y_,z_,roll,pitch,yaw,vx,vy,vz,p,q,r)
    state_dim = 12

    # Control input vector
    u1 = cs.MX.sym('u1')
    u2 = cs.MX.sym('u2')
    u3 = cs.MX.sym('u3')
    u4 = cs.MX.sym('u4')
    u = cs.vertcat(u1, u2, u3, u4)

    my_quad = px4_quad()
    # p_dynamics
    pos_dynamics = cs.vertcat(vx,vy,vz)

    #q_dynamics
    angle_dynamics = cs.vertcat(
        p+r*(cs.cos(roll) * cs.tan(pitch))+q*(cs.sin(roll)*cs.tan(pitch)),
        q*cs.cos(roll) - r*cs.sin(roll),
        r*(cs.cos(roll)/cs.cos(pitch)) + q * (cs.sin(roll)/cs.cos(pitch)))

    # v_dynamics
    g = -9.81
    ft = (u1 + u2 + u3 + u4)*my_quad.max_thrust
    taux = (u3 - u1)*my_quad.max_thrust*my_quad.length
    tauy = (u4 - u2)*my_quad.max_thrust*my_quad.length
    tauz = (u2 + u4 - u1 - u3)*my_quad.max_thrust*my_quad.length
    v_dynamics = cs.vertcat(
        r*vy-q*vz-g*cs.sin(pitch),
        p*vz-r*vx+g*cs.sin(roll)*cs.cos(pitch),
        q*vx-p*vy + g*cs.cos(pitch)*cs.cos(roll) + ft/my_quad.mass)
    #w_dynamics 
    w_dynamics = cs.vertcat(
            (my_quad.J[1] - my_quad.J[2])/my_quad.J[0] * r * q + taux/my_quad.J[0],
            (my_quad.J[2] - my_quad.J[0])/my_quad.J[1] * r * p + tauy/my_quad.J[1],
            (my_quad.J[0] - my_quad.J[1])/my_quad.J[2] * p * q + tauz/my_quad.J[2])

    
    pdot = cs.MX.sym('pdot', 3)  # position
    qdot = cs.MX.sym('adot', 3)  # angle roll pitch yaw
    vdot = cs.MX.sym('vdot', 3)  # velocity
    rdot = cs.MX.sym('rdot', 3)  # angle rate
    xdot = cs.vertcat(pdot, qdot, vdot, rdot)

    normails = cs.vertcat(pos_dynamics, angle_dynamics, v_dynamics, w_dynamics)
    f_impl = xdot - normails

    model_name = 'px4_quad_linear_model'

    # Dynamics model
    model = AcadosModel()
    model.f_expl_expr = normails
    model.f_impl_expr = f_impl
    model.x = x
    model.xdot = xdot
    model.u = u
    model.p = []
    model.name = 'px4_quad_linear_model'

    return model

def DT_linear_model(dT,name):
    model = linear_quad_model()
    x = model.x
    u = model.u
    model.name = f'px4_quad_linear_model_{name}'
    ode = cs.Function('ode',[x, u], [model.f_expl_expr])
    # set up Rk4
    k1 = ode(x,       u)
    k2 = ode(x+dT/2*k1,u)
    k3 = ode(x+dT/2*k2,u)
    k4 = ode(x+dT*k3,  u)
    xf = x + dT/6 * (k1 + 2*k2 + 2*k3 + k4)

    model.disc_dyn_expr = xf
    return model

def kernel(x1, x2,sigf,l):
    x1 = x1.T
    x2 = x2.T
    dist_matrix = np.sum(x1**2, 1).reshape(-1, 1) + np.sum(x2**2, 1) - 2 * np.dot(x1, x2.T)
    return sigf ** 2 * np.exp(-0.5 / l ** 2 * dist_matrix)


def DT_gp_model(dT,name,predict,measurement,control,total_buff_size):
    model = linear_quad_model()
    x = model.x
    u = model.u
    model.name = f'px4_quad_linear_model_{name}'
    ode = cs.Function('ode',[x, u], [model.f_expl_expr])
    # set up Rk4
    k1 = ode(x,       u)
    k2 = ode(x+dT/2*k1,u)
    k3 = ode(x+dT/2*k2,u)
    k4 = ode(x+dT*k3,  u)
    xf = x + dT/6 * (k1 + 2*k2 + 2*k3 + k4)
    
    # fit gp model
    t0 = time.time()

    x1 = (measurement[:,0:-1])
    x2 = (control[:,0:-1])
    input_state = np.concatenate(( x1 , x2 ), axis=0)
    error_y = (measurement[:,1:] - predict[:,1:])[6:9,:]
    # use 100 points in GP 
    down_sample_factor = int(total_buff_size / 100 )
    input_state = input_state[:,::down_sample_factor]
    error_y = error_y[:,::down_sample_factor]

    sig_f = np.std(error_y)
    print(input_state.shape)
    print(error_y.shape)
    
    X = input_state
    Y = error_y
    l = np.genfromtxt('Final_train_set/length_scale.out',delimiter=',') / (6 / down_sample_factor)
    print('length_scale:', l)
    K = kernel(X,X,sig_f,l)
    #print('x',x.shape)
    #print('u',u.shape)
    #print('x + u',cs.vertcat(x,u))
    #print('x + u',cs.vertcat(x,u).shape)
    x1 = cs.vertcat(x,u).T
    x2 = X.T
    dist_matrix = cs.sum2(x1**2) + cs.sum2(x2**2) - ((cs.mtimes(x1, x2.T))*2).T
    Kstar = (sig_f ** 2 * np.exp(-0.5 / l ** 2 * dist_matrix)).T
    error = cs.mtimes ( cs.mtimes(Kstar,np.linalg.inv(K) ), Y.T ).T
    error = cs.vertcat(cs.MX([0,0,0,0,0,0]),error,cs.MX([0,0,0]))
    print('====================fit========================')
    print('length-scale:',l)
    print('sig-f:',sig_f)
    print('size of train set:',error_y.shape)
    print('time for fit GP model',time.time() - t0)
    model.disc_dyn_expr = xf + error
    return model

    
def acados_settinngs(acados_models,solver_options = None,t_horizon = 1,N = 20,build=True, generate=True):
    
    my_quad = px4_quad()
    
    q_cost = np.array([15, 15, 15, 1, 1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 1])
    r_cost = np.array([0.5, 0.5, 0.5, 0.5])
     
    nx = acados_models.x.size()[0]
    nu = acados_models.u.size()[0]
    ny = nx + nu
    ny_e = nx

    n_param = acados_models.p.size()[0] if isinstance(acados_models.p, cs.MX) else 0
    ocp = AcadosOcp()
    ocp.model = acados_models
    ocp.dims.N = N
    ocp.solver_options.tf = t_horizon

    # Initialize parameters

    ocp.dims.np = n_param
    ocp.parameter_values = np.zeros(n_param)

    ocp.cost.cost_type = 'NONLINEAR_LS'
    ocp.cost.cost_type_e = 'NONLINEAR_LS'
    
    ocp.model.cost_y_expr = cs.vertcat(ocp.model.x, ocp.model.u)
    ocp.model.cost_y_expr_e = ocp.model.x


    ocp.cost.W = np.diag(np.concatenate((q_cost, r_cost)))
    ocp.cost.W_e = np.diag(q_cost)
    ocp.cost.W_e *= 1


    # Initial reference trajectory (will be overwritten)
    x_ref = np.zeros(nx)
    ocp.cost.yref = np.concatenate((x_ref, np.array([0.0, 0.0, 0.0, 0.0])))
    ocp.cost.yref_e = x_ref
    ocp.constraints.x0 = x_ref

    # Set constraints
    ocp.constraints.lbu = np.array([my_quad.min_u] * 4)
    ocp.constraints.ubu = np.array([my_quad.max_u] * 4)



    ocp.constraints.idxbu = np.array([0,1,2,3])
    # Solver options
    ocp.solver_options.qp_solver = 'PARTIAL_CONDENSING_HPIPM'
    ocp.solver_options.hessian_approx = 'GAUSS_NEWTON'
    ocp.solver_options.integrator_type = 'DISCRETE'
    ocp.solver_options.print_level = 0
    ocp.solver_options.nlp_solver_type = 'SQP_RTI'
    ocp.solver_options.regularize_method = 'CONVEXIFY'
    ocp.solver_options.nlp_solver_max_iter = 20
    t1 = time.time()
    acados_solver = AcadosOcpSolver(ocp, json_file='acados_ocp.json',build=build, generate=generate)
    print('=============================FINISHED nonlinear_LS ACADOS SOLVER SETTINGS ===========================')
    print('time for build the solver:',time.time()-t1)
    return acados_solver



def run_solver(N,model,acados_solver,initial_state,ref):
    
    u_target = np.zeros((N+1,4))
    ref = np.concatenate((ref, u_target),axis = 1)
    for j in range(N):
        acados_solver.set(j, "yref", ref[j])
    acados_solver.set(N, "yref", ref[N][:-4])
    
    # Set initial state.
    x_init = initial_state
    x_init = np.stack(x_init)
    # Set initial condition, equality constraint
    acados_solver.set(0, 'lbx', x_init)
    acados_solver.set(0, 'ubx', x_init)

    # Solve OCP
    acados_solver.solve()
    # get vx vy vz 
    x_next = acados_solver.get(10, "x")
    vx_next = x_next[6]
    vy_next = x_next[7]
    vz_next = x_next[8]
    p_next = x_next[9]
    q_next = x_next[10]
    r_next = x_next[11]	
    control = acados_solver.get(0, "u")
    return vx_next,vy_next,vz_next,p_next,q_next,r_next,control

def solve_DT_nextState(model,input_u ,current_x):
    x = model.x
    u = model.u
    xf = model.disc_dyn_expr
    DTsolution = cs.Function('f',[u,x],[xf])
    result = DTsolution(input_u,current_x)

    return result




